### **Updated Mathematical Formulation: Applying All Rules at the Block Level**

Now that you've moved **SignPatternRule** and **CardinalityRule** to **block rules** (instead of intra-block rules), the formulation changes as follows:

---

## **1. Updated Ordering Framework**

We are given a **Mixed-Integer Linear Program (MILP)**:

\[
\begin{aligned}
\text{Minimize: } & \quad c^T x \\
\text{subject to: } & \quad A x \,\square\, b, \\
                   & \quad \ell \le x \le u, \\
                   & \quad x_j \in \mathbb{Z} \text{ if } j \in \mathcal{I}, \quad x_j \in \{0,1\} \text{ if } j \in \mathcal{B}, \\
\end{aligned}
\]

where:
- \( x \) is the vector of decision variables,
- \( A \) is the **constraint matrix**,
- \( b \) is the **right-hand side vector**,
- \( c \) is the **objective coefficient vector**,
- \( \ell, u \) are variable **bounds**,
- \( \mathcal{B} \) are indices of **binary variables**,
- \( \mathcal{I} \) are indices of **general integer variables**,
- the rest of the variables are **continuous**.

We need to **sort** both **variables** and **constraints** **hierarchically** based on their **structural and numerical properties**.  
Previously, some rules were **intra-block**, but now **all rules define blocks**, meaning they determine the **high-level partitioning first**, and ordering is resolved **only by recursion**.

---

## **2. Variable Ordering**

Each variable \( x_j \) is classified into a **block label tuple** based on:
1. **Variable type** (binary, integer, continuous)
2. **Bound category** (finite vs. infinite bounds)
3. **Sign pattern of the column in \( A \)** (all positive, all negative, or mixed)
4. **Cardinality** (number of nonzero coefficients in its column of \( A \))

### **2.1 Block Rules for Variables**
Each variable \( x_j \) receives a **tuple** of integer labels:

1. **VariableTypeRule:** Assigns a **discrete category** based on type:
   \[
   \text{VarType}_j =
   \begin{cases}
   3, & x_j \text{ is binary} \\
   2, & x_j \text{ is general integer} \\
   1, & x_j \text{ is continuous}
   \end{cases}
   \]
   
2. **BoundCategoryRule:** Assigns a category based on its bounds:
   \[
   \text{BoundCategory}_j =
   \begin{cases}
   2, & \ell_j, u_j \text{ are finite} \\
   1, & \text{Otherwise}
   \end{cases}
   \]

3. **SignPatternRule:** Classifies based on coefficient signs:
   \[
   \text{hasPos}_j \;=\; \exists\, i: A_{i,j} > 10^{-15}, 
   \quad 
   \text{hasNeg}_j \;=\; \exists\, i: A_{i,j} < -10^{-15}.
   \]
   Then:
   \[
   \text{SignPattern}_j =
   \begin{cases}
   2, & \text{if hasPos}_j \text{ AND not hasNeg}_j \\
   1, & \text{if hasNeg}_j \text{ AND not hasPos}_j \\
   0, & \text{otherwise (mixed or zero)}
   \end{cases}
   \]

4. **CardinalityRule:** Computes the number of nonzero coefficients:
   \[
   \text{Cardinality}_j = \# \{\, i \mid A_{i,j} \neq 0 \,\}
   \]

Thus, **each variable is assigned a tuple**:
\[
\left( \text{VarType}_j, \text{BoundCategory}_j, \text{SignPattern}_j, \text{Cardinality}_j \right).
\]
**Sorting is done lexicographically** over this tuple.

---

## **3. Constraint Ordering**

Each **constraint** (row of \( A \)) is classified into **blocks** based on:
1. **Composition of the constraint** (binary/integer/mixed)
2. **Sign pattern of the constraint row**
3. **Cardinality** (number of nonzero coefficients in the row)

### **3.1 Block Rules for Constraints**
Each constraint \( i \) is assigned a **block label tuple**:

1. **ConstraintCompositionRule:** Assigns a label based on whether the constraint contains only binary, integer, or continuous variables:
   \[
   \text{Composition}_i =
   \begin{cases}
   2, & \text{if all variables are binary or integer} \\
   1, & \text{if all variables are continuous} \\
   0, & \text{if mixed}
   \end{cases}
   \]

2. **SignPatternRule:** Classifies based on coefficient signs in row \( i \):
   \[
   \text{hasPos}_i \;=\; \exists\, j: A_{i,j} > 10^{-15}, 
   \quad 
   \text{hasNeg}_i \;=\; \exists\, j: A_{i,j} < -10^{-15}.
   \]
   Then:
   \[
   \text{SignPattern}_i =
   \begin{cases}
   2, & \text{if hasPos}_i \text{ AND not hasNeg}_i \\
   1, & \text{if hasNeg}_i \text{ AND not hasPos}_i \\
   0, & \text{otherwise (mixed or zero)}
   \end{cases}
   \]

3. **CardinalityRule:** Computes the number of nonzero coefficients:
   \[
   \text{Cardinality}_i = \# \{\, j \mid A_{i,j} \neq 0 \,\}
   \]

Thus, **each constraint is assigned a tuple**:
\[
\left( \text{Composition}_i, \text{SignPattern}_i, \text{Cardinality}_i \right).
\]
**Sorting is done lexicographically** over this tuple.

---

## **4. Recursive Implementation**
The recursive class **`RecursiveHierarchicalRuleComposition`** implements **block-wise sorting** with the following steps:

1. **Partitioning:**  
   - We **recursively partition** the set of variables/constraints using **block rules** in a hierarchical manner.
   - The **first rule** partitions variables/constraints into **disjoint subsets** (e.g., binary vs. integer vs. continuous).
   - Within each subset, we apply the **next block rule**, further dividing items.

2. **Recursion:**  
   - If applying a rule does **not** change the partitioning, stop recursion.
   - Otherwise, continue partitioning **until no further refinement occurs**.

3. **Final Sorting:**  
   - Once recursion terminates, the **final order** is determined lexicographically by the assigned **block tuples**.

### **Mathematical Representation of Recursion**
Define the **set of variables** as \( \mathcal{V} \) and the **set of constraints** as \( \mathcal{C} \).

The **partitioning function** recursively refines the ordering:
\[
\mathcal{V} = \bigcup_{k} \mathcal{V}_k, \quad \mathcal{V}_k \cap \mathcal{V}_m = \emptyset \text{ for } k \neq m.
\]
\[
\mathcal{C} = \bigcup_{k} \mathcal{C}_k, \quad \mathcal{C}_k \cap \mathcal{C}_m = \emptyset \text{ for } k \neq m.
\]

Let \( f_B(x) \) be the **block rules**, and let \( g_B(x) \) be the **intra-block rules**.

\[
\text{Sort}_\text{Recursive}(\mathcal{V}) =
\begin{cases}
\text{Sort}_\text{Recursive}(\mathcal{V}_1) \cup \dots \cup \text{Sort}_\text{Recursive}(\mathcal{V}_m), & \text{if partitioning changed}, \\
\text{LexSort}(\mathcal{V}, g_B), & \text{otherwise}.
\end{cases}
\]

Thus, **all ordering is defined purely by the block structure**, and **no intra-block numeric sorting is performed anymore**.

---

## **5. Conclusion**
Now, all partitioning is **strictly determined by block rules**:
- **High-level partitions first** (type, bound category, composition).
- **More refined partitions next** (sign pattern, cardinality).
- **Recursively applied** until no further refinement is possible.

This method ensures a **stable, deterministic** ordering that is **scale-invariant** and **solver-agnostic**.